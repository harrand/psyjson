json_data_type ::= enum
{
	.string_literal := 0;
	.numeric_literal := 1;
	.bool_literal := 2;
	.null_literal := 3;
	.array := 4;
	.object := 5;
};

json_number_type ::= enum
{
	.integral := 0;
	.floating_point := 1;
};

json_data ::= struct
{
	type : json_data_type;
	is_floating_point : bool;
	integral : s64;
	floating_point : f64;
	boolean : bool;
	chars : u8?;
	chars_len : u64;

	children : v0?;
	childcap : u64;
	childcount : u64;

	loc : srcloc;
};

json_data_add_child ::= func(n : json_data mut?, c : json_data, a : arena mut? -> json_data mut?)
{
	if(n->children == zero)
	{
		n->childcap = 8;
		n->children = arena_alloc(a, __sizeof(json_data) * (n->childcap));
	}
	while(n->childcount >= (n->childcap))
	{
		oldcap ::= n->childcap;
		olddata ::= n->children;
		n->childcap = (n->childcap * 2);
		n->children = arena_alloc(a, __sizeof(json_data) * (n->childcap));
		memcopy(n->children, olddata, __sizeof(json_data) * oldcap);
	}
	ptr ::= (n->children)@json_data mut? mut;
	ptr = (ptr#(n->childcount));
	n->childcount = (n->childcount + 1);
	deref(ptr) = c;
	return ptr;
};

json_data_get_child ::= func(n : json_data, idx : u64 -> json_data mut?)
{
	cptr ::= (n.children)@json_data mut?;
	return cptr#idx;
};

json_data_verbose_print ::= func(j : json_data, tabcount : u64 -> v0)
{
	i : u64 mut;
	for(i = 0, i < tabcount, i = i + 1)
	{
		putchar(9);
	}
	putzstr(__enumname(j.type));
	putzstr(" ");
	putloc(j.loc);
	putchar(10);
	cptr ::= (j.children)@json_data?;
	for(i = 0, i < (j.childcount), i = i + 1)
	{
		json_data_verbose_print(deref(cptr # i), tabcount + 1);
	}
};
