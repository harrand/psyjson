json_parse_state ::= struct
{
	nodes : json_data mut?;
	nodes_size : u64;
	nodes_cap : u64;
	internal : internal_json_parse_state mut;
	err_flag : bool;
};

internal_json_parse_state ::= struct
{
	parent : v0? weak;
	stash : json_data mut?;
	stash_size : u64;
	stash_cap : u64;

	lex_cursor : u64;
	last_string : json_data;
	has_last_string : bool;
};

stash_pop ::= func(i : internal_json_parse_state mut? -> json_data)
{
	stashlast ::= deref(i->stash # ((i->stash_size) - 1));
	i->stash_size = ((i->stash_size) - 1);
	return stashlast;
};

stash_peek ::= func(i : internal_json_parse_state? -> json_data mut?)
{
	return i->stash # ((i->stash_size) - 1);
};

stash_push ::= func(i : internal_json_parse_state mut?, j : json_data, a : arena mut? -> v0)
{
	if(i->stash == zero)
	{
		i->stash_cap = 64;
		i->stash = arena_alloc(a, __sizeof(json_data) * (i->stash_cap));
	}
	while(i->stash_cap < (i->stash_size))
	{
		oldcap ::= i->stash_cap;
		olddata ::= i->stash;
		i->stash_cap = ((i->stash_cap) * 2);
		i->stash = arena_alloc(a, __sizeof(json_data) * (i->stash_cap));
		memcopy(i->stash, olddata, __sizeof(json_data) * oldcap);
	}
	deref(i->stash # (i->stash_size)) = j;
	i->stash_size = (i->stash_size) + 1;
};

json_parse_push ::= func(s : json_parse_state mut?, j : json_data, a : arena mut? -> v0)
{
	if(s->nodes == zero)
	{
		s->nodes_cap = 8;
		s->nodes = arena_alloc(a, __sizeof(json_data) * (s->nodes_cap));
	}
	while(s->nodes_cap < (s->nodes_size))
	{
		oldcap ::= s->nodes_cap;
		olddata ::= s->nodes;
		s->nodes_cap = (s->nodes_cap) * 2;
		s->nodes = arena_alloc(a, __sizeof(json_data) * (s->nodes_cap));
		memcopy(s->nodes, olddata, __sizeof(json_data) * oldcap);
	}
	deref(s->nodes # (s->nodes_size)) = j;
	s->nodes_size = (s->nodes_size) + 1;
};

json_parse_error ::= func(s : json_parse_state mut? weak, errmsg : u8?, loc : srcloc, a : arena mut? -> v0)
{
	if(s->nodes_cap == 0)
	{
		s->nodes_cap = 1;
		s->nodes = arena_alloc(a, __sizeof(json_data));
	}
	deref((s->nodes)) = json_data
	{
		.type := json_data_type.error;
		.chars := errmsg;
		.chars_len := zstrlen(errmsg);
		.children := zero;
		.childcap := zero;
		.childcount := zero;
		.loc := loc;
	};
	s->nodes_size = 1;
	s->err_flag = true;
};

json_parse_one ::= func(l : json_lex_state, s : json_parse_state mut?, a : arena mut? -> v0)
{
	i ::= ref(s->internal);
	token ::= deref(l.tokens # (i->lex_cursor));
	if(token.tok == json_lex_token.string_literal)
	{
		str ::= json_data
		{
			.type := json_data_type.string_literal;
			.chars := (l.src) # (token.json_lexeme.off);
			.chars_len := token.json_lexeme.len;
			.children := zero;
			.childcap := zero;
			.childcount := zero;
			.loc := token.begin;
		};

		// peek at the stash
		// if the top is a string literal
		// then we are a string value not a key
		if(i->stash_size > 0)
		{
			stashed ::= stash_peek(i);
			if(stashed->type == json_data_type.array)
			{
				// no concept of last_string here, just add it
				json_data_add_child(stashed, str, a);		
			}
			else
			{
				if(stashed->type == json_data_type.string_literal)
				{
					json_data_add_child(stashed, str, a);		
				}
				else
				{
					i->last_string = str;
					i->has_last_string = true;
				}
			}
		}
	}
	if(token.tok == json_lex_token.comma)
	{
		// if top of stash is an array
		// ignore it
		if(i->stash_size == 0)
		{
			json_parse_error(i->parent, "syntax error: invalid comma.", token.begin, a);
			return;
		}
		if(stash_peek(i)->type != json_data_type.array)
		{
			// end of a thing.
			// take it off of the stash
			thing ::= stash_pop(i);
			// if the stash is now empty then we have a top-level object. just add it to json_parse_state.nodes
			// if stash is not empty then this is a subobject. add it as a child to that instead.
			if(i->stash_size == 0)
			{
				json_parse_push(s, thing, a);
			}
			else
			{
				peeked_top ::= stash_peek(i);
				json_data_add_child(peeked_top, thing, a);
			}
		}
	}
	if(token.tok == json_lex_token.colon)
	{
		if(!(i->has_last_string))
		{
			json_parse_error(i->parent, "syntax error: colon does not directly proceed a string literal.", token.begin, a);
			return;
		}
		stash_push(i, i->last_string, a);
		i->has_last_string = false;
		i->last_string = zero;
	}
	if(token.tok == json_lex_token.obrace)
	{
		// start of a new object. snore
		// make an object json_data that is empty and shove it into the stash.
		stash_push(i, json_data
		{
			.type := json_data_type.object;
			.children := zero;
			.childcap := zero;
			.childcount := zero;
			.loc := token.begin;
		}, a);
	}
	if(token.tok == json_lex_token.cbrace)
	{
		// note: in json a key-value pair doesnt have to end with a trailing comma if a cbrace is coming next
		// we handle that case by: if the thing at the top of the stash is not an object then just commit that right now and continue on assuming the next thing must be the object itself.
		if(stash_peek(i)->type != json_data_type.object)
		{
			last_kv ::= stash_pop(i);	
			json_data_add_child(stash_peek(i), last_kv, a);
		}
		// end of an object.
		// take it off of the stash
		obj ::= stash_pop(i);
		if(obj.type != json_data_type.object)
		{
			json_parse_error(i->parent, "syntax error: invalid closing brace - stashtop is not an object", token.begin, a);
			return;
		}
		// if the stash is now empty then we have a top-level object. just add it to json_parse_state.nodes
		// if stash is not empty then this is a subobject. add it as a child to that instead.
		if(i->stash_size == 0)
		{
			json_parse_push(s, obj, a);
		}
		else
		{
			json_data_add_child(stash_peek(i), obj, a);
		}
	}
	if(token.tok == json_lex_token.numeric_literal)
	{
		num ::= json_data mut
		{
			.type := json_data_type.numeric_literal;
			.children := zero;
			.childcap := zero;
			.childcount := zero;
			.loc := token.begin;
		};
		if(!json_interpret_numeric_literal(ref num, l.src # (token.json_lexeme.off), token.json_lexeme.len))
		{
			json_parse_error(i->parent, "syntax error: failed to parse numeric literal", token.begin, a);
			return;
		}
		if(i->stash_size == 0)
		{
			json_parse_push(s, num, a);
		}
		else
		{
			json_data_add_child(stash_peek(i), num, a);
		}
	}
	if(token.tok == json_lex_token.obrack)
	{
		// start of a new array. snore
		// make an object json_data that is empty and shove it into the stash.
		stash_push(i, json_data
		{
			.type := json_data_type.array;
			.children := zero;
			.childcap := zero;
			.childcount := zero;
			.loc := token.begin;
		}, a);
	}
	if(token.tok == json_lex_token.cbrack)
	{
		// note: in json the last array element doesnt have to have a proceeding comma
		// we handle that case by: if the thing at the top of the stash is not an object then just commit that right now and continue on assuming the next thing must be the object itself.
		if(stash_peek(i)->type != json_data_type.array)
		{
			last_elem ::= stash_pop(i);	
			json_data_add_child(stash_peek(i), last_elem, a);
		}
		// end of an object.
		// take it off of the stash
		arr ::= stash_pop(i);
		if(arr.type != json_data_type.array)
		{
			json_parse_error(i->parent, "syntax error: invalid closing bracket - stashtop is not an array", token.begin, a);
			return;
		}
		// if the stash is now empty then we have a top-level array. just add it to json_parse_state.nodes
		if(i->stash_size == 0)
		{
			json_parse_push(s, arr, a);
		}
		else
		{
			json_data_add_child(stash_peek(i), arr, a);
		}
	}
	if(token.tok == json_lex_token.keyword_true)
	{
		tboolean ::= json_data
		{
			.type := json_data_type.bool_literal;
			.boolean := true;
			.children := zero;
			.childcap := zero;
			.childcount := zero;
			.loc := token.begin;
		};
		if(i->stash_size == 0)
		{
			json_parse_push(s, tboolean, a);
		}
		else
		{
			json_data_add_child(stash_peek(i), tboolean, a);
		}
	}
	if(token.tok == json_lex_token.keyword_false)
	{
		fboolean ::= json_data
		{
			.type := json_data_type.bool_literal;
			.boolean := false;
			.children := zero;
			.childcap := zero;
			.childcount := zero;
			.loc := token.begin;
		};
		if(i->stash_size == 0)
		{
			json_parse_push(s, fboolean, a);
		}
		else
		{
			json_data_add_child(stash_peek(i), fboolean, a);
		}
	}
	if(token.tok == json_lex_token.keyword_null)
	{
		null ::= json_data
		{
			.type := json_data_type.null_literal;
			.children := zero;
			.childcap := zero;
			.childcount := zero;
			.loc := token.begin;
		};
		if(i->stash_size == 0)
		{
			json_parse_push(s, null, a);
		}
		else
		{
			json_data_add_child(stash_peek(i), null, a);
		}
	}
	i->lex_cursor = (i->lex_cursor) + 1;
};

json_do_parse ::= func(l : json_lex_state, a : arena mut?, verbose_parse : bool -> json_data)
{
	i : u64 mut;

	ret ::= zero@json_parse_state mut;
	ret.internal.parent = (ref ret);
	while(ret.internal.lex_cursor < (l.tokens_size))
	{
		json_parse_one(l, ref ret, a);
	}
	if(verbose_parse)
	{
		for(i = 0, i < (ret.nodes_size), i = i + 1)
		{
			json_data_verbose_print(deref(ret.nodes # i), 0);
		}
	}
	if(ret.nodes_size > 1)
	{
		json_parse_error(ref ret, "syntax error: more than one top-level value in json document", zero, a);
	}
	return deref(ret.nodes);
};

isdigit ::= func(c : u8 -> bool)
{
	return (c >= '0') && (c <= '9');
};

// return false if error occurred
json_interpret_numeric_literal ::= func(j : json_data mut?, src : u8?, len : u64 -> bool)
{
	src_begin : u8? mut := src;
	begin_cpy ::= src_begin;
	i : u64 mut := 0;

	sign : s64 mut := 1;
	if(deref(src_begin) == '-')
	{
		sign = -1;
		src_begin = src_begin # 1;
		i = i + 1;
	}

	base : s64 mut := 10;
	ch : u8 mut;
	if(deref(src_begin) == '0')
	{
		src_begin = src_begin # 1;
		ch = deref(src_begin);
		if(ch == 'x')
		{
			base = 16;
			src_begin = src_begin # 1;
			i = i + 2;
		}
		if(ch == 'b')
		{
			base = 2;
			src_begin = src_begin # 1;
			i = i + 2;
		}
	}

	ival : s64 mut := 0;
	fval : f64 mut := 0;

	digit_val : s64 mut := 0;
	frac_div : f64 mut := 1.0;

	is_integral : bool mut := true;
	while(i < len)
	{
		ch = deref(begin_cpy # i);
		if(ch == '.')
		{
			is_integral = false;
		}
		if(isdigit(ch))
		{
			digit_val = (ch - '0')@_;
		}
		if(ch >= 'a')
		{
			if(ch <= 'f')
			{
				digit_val = (10 + (ch - 'a'));
			}
		}
		if(ch >= 'A')
		{
			if(ch <= 'F')
			{
				digit_val = (10 + (ch - 'A'));
			}
		}

		if(digit_val >= base)
		{
			return false;
		}

		if(is_integral)
		{
			ival = ((ival * base) + digit_val);
		}
		if(!is_integral)
		{
			if(isdigit(ch))
			{
				frac_div = (frac_div / (base@f64));
				fval = (fval + ((digit_val@f64) * frac_div));
			}
		}

		i = i + 1;
	}

	if(is_integral)
	{
		j->integral = ival;
		j->is_floating_point = false;
	}
	if(!is_integral)
	{
		j->floating_point = fval;
		j->is_floating_point = true;
	}
	return true;
};
