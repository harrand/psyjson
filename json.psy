== default ==
{
	add_source_directory("src");
	add_build_file("psystdlib/stdlib.psy", _config);

	set_executable("json");
}

global_arena_val : arena mut;
global_arena : arena mut? mut;

frame_arena_val : arena mut;
frame_arena : arena mut? mut;

setup_arenas ::= func( -> v0)
{
	global_arena_val = arena_create(4096 * 1024);
	global_arena = ref global_arena_val;

	frame_arena_val = arena_create(4096 * 1024);
	frame_arena = ref frame_arena_val;
};

destroy_arenas ::= func( -> v0)
{
	putzstr("arena free: ");
	putuint(global_arena_val.cur);
	putzstr("B");
	putchar(10);
	arena_destroy(ref global_arena_val);
	arena_destroy(ref frame_arena_val);
};

fully_read_file ::= func(path : u8?, a : arena mut? -> u8 mut?)
{
	if(!file_exists(path))
	{
		putzstr("file ");
		putchar('"');
		putzstr(path);
		putchar('"');
		putzstr(" could not be located (cwd: ");
		cwd : u8? mut;
		cwdlen : u64 mut;
		directory_get_cwd(ref cwd, ref cwdlen, global_arena);
		putbytes(cwd, cwdlen);
		putzstr(")");
		__debugbreak();
	}
	len ::= file_size_bytes(path);
	if(len == 0)
	{
		putzstr("warning: file ");
		putchar('"');
		putzstr(path);
		putchar('"');
		putzstr(" exists but is empty");
	}
	data : u8 mut? := arena_alloc(a, len + 1);
	file_read(path, data, len);
	deref(data # len) = 0;
	return data;
};

argc : s32 mut;
argv : u8?? mut;
envp : u8?? mut;

main ::= func(iargc : s32, iargv : u8??, ienvp : u8?? -> s32)
{
	argc = iargc;
	argv = iargv;
	envp = ienvp;
	setup_arenas();
	defer destroy_arenas();
	lex_setup(global_arena);

	args ::= json_parse_args(global_arena);
	if(args.file == zero)
	{
		putzstr("error: no file provided");
		putchar(10);
		__debugbreak();
	}
	source ::= fully_read_file(args.file, global_arena);
	tokens ::= lex(args.file, source, false, global_arena);
	json ::= parse(tokens, global_arena, true);
	
	return 0;
};
