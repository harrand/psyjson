== default ==
{
	debug();
}

== debug ==
{
	base();
}

== release ==
{
	base();
}

== base ==
{
	add_source_directory("src");
	add_build_file("psystdlib/stdlib.psy", "default");
	set_object("json");
}

global_arena_val : arena mut;
global_arena : arena mut? mut;

frame_arena_val : arena mut;
frame_arena : arena mut? mut;

setup_arenas ::= func( -> v0)
{
	global_arena_val = arena_create(4096 * 1024);
	global_arena = ref global_arena_val;

	frame_arena_val = arena_create(4096 * 1024);
	frame_arena = ref frame_arena_val;
};

destroy_arenas ::= func( -> v0)
{
	putzstr("arena free: ");
	putuint(global_arena_val.cur);
	putzstr("B");
	putchar(10);
	arena_destroy(ref global_arena_val);
	arena_destroy(ref frame_arena_val);
};

fully_read_file ::= func(path : u8?, a : arena mut? -> u8 mut?)
{
	if(!file_exists(path))
	{
		putzstr("file ");
		putchar('"');
		putzstr(path);
		putchar('"');
		putzstr(" could not be located (cwd: ");
		cwd : u8? mut;
		cwdlen : u64 mut;
		directory_get_cwd(ref cwd, ref cwdlen, global_arena);
		putbytes(cwd, cwdlen);
		putzstr(")");
		__debugbreak();
	}
	len ::= file_size_bytes(path);
	if(len == 0)
	{
		putzstr("warning: file ");
		putchar('"');
		putzstr(path);
		putchar('"');
		putzstr(" exists but is empty");
	}
	data : u8 mut? := arena_alloc(a, len + 1);
	file_read(path, data, len);
	deref(data # len) = 0;
	return data;
};

json_parse_buffer_named ::= func(name : u8?, buf : u8?, len : u64, a : arena mut? -> json_data)
{
	tokens ::= json_lex(name, buf, len, false, a);
	return json_do_parse(tokens, global_arena, false);
};

json_parse_buffer ::= func(buf : u8?, len : u64, a : arena mut? -> json_data)
{
	return json_parse_buffer_named("<untitled json buffer>", buf, len, a);
};

json_parse_file ::= func(path : u8?, a : arena mut? -> json_data)
{
	source ::= fully_read_file(path, a);
	return json_parse_buffer_named(path, source, zstrlen(source), a);
};

json_print ::= func(j : json_data -> v0)
{
	json_data_verbose_print(j, 0);
};

json_array_length ::= func(j : json_data -> u64)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.array))
		{
			putzstr("json_array_length called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
	}
	return j.childcount;
};

json_object_field_count ::= func(j : json_data -> u64)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.object))
		{
			putzstr("json_object_field_count called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
	}
	return j.childcount;
};

// retrieve a field of an object by index. the index must be in range (see json_object_field_count)
json_object_get_field ::= func(j : json_data, field_idx : u64 -> json_data mut?)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.object))
		{
			putzstr("json_object_get_field called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
		if(field_idx >= (j.childcount))
		{
			putzstr("json_object_get_field requested index ");
			putuint(field_idx);
			putzstr(" but object only had ");
			putuint(j.childcount);
			putzstr(" fields.");
			__debugbreak();
		}
	}
	return json_data_get_child(j, field_idx);
};

// retrieve a field of an object by name
// if the object has a field by this name, its value is returned
// else zero is returned
json_object_find_field ::= func(j : json_data, name : u8?, name_len : u64 -> json_data mut?)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.object))
		{
			putzstr("json_object_find_field called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
	}
	i : u64 mut;
	for(i = 0, i < (j.childcount), i = i + 1)
	{
		field ::= json_data_get_child(j, i);
		// field is a string
		// stringdata is the name of the field
		// its only child is the field value
		if(field->chars_len == name_len)
		{
			if(streql_n(field->chars, name, name_len))
			{
				// this is the one
				return json_data_get_child(deref field, 0);
			}
		}
	}
	return zero;
};

json_object_find_fieldz ::= func(j : json_data, name_zstr : u8? -> json_data mut?)
{
	return json_object_find_field(j, name_zstr, zstrlen(name_zstr));
};

json_string_length ::= func(j : json_data -> u64)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.string_literal))
		{
			putzstr("json_string_length called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
	}
	return j.chars_len;
};

json_string_data ::= func(j : json_data -> u8?)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.string_literal))
		{
			putzstr("json_string_data called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
	}
	return j.chars;
};

// retrieves the specific type of a number (i.e floating point or integer)
json_number_get_type ::= func(j : json_data -> s64)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.numeric_literal))
		{
			putzstr("json_number_get_type called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
	}
	if(j.is_floating_point)
	{
		return json_number_type.floating_point;
	}
	return json_number_type.integral;
};

// get a number value as a signed 64 bit integer. works for any number
json_number_get_integer ::= func(j : json_data -> s64)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.numeric_literal))
		{
			putzstr("json_number_get_int called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
	}
	if(j.is_floating_point)
	{
		return j.floating_point@s64;
	}
	return j.integral;
};

// get a number value as a 64 bit floating point value. works for any number
json_number_get_float ::= func(j : json_data -> f64)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.numeric_literal))
		{
			putzstr("json_number_get_float called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
	}
	if(j.is_floating_point)
	{
		return j.floating_point;
	}
	return j.integral@f64;
};
