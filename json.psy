== default ==
{
	warning("No build config specified. Defaulting to debug...");
	debug();
}

== debug ==
{
	debug_symbols(true);
	set_optimization(0);
	base();
}

== release ==
{
	set_optimization(3);
	base();
}

== base ==
{
	add_source_directory("src");
	add_build_file("psystdlib/stdlib.psy", "default");

	set_executable("json");
}

global_arena_val : arena mut;
global_arena : arena mut? mut;

frame_arena_val : arena mut;
frame_arena : arena mut? mut;

setup_arenas ::= func( -> v0)
{
	global_arena_val = arena_create(4096 * 1024);
	global_arena = ref global_arena_val;

	frame_arena_val = arena_create(4096 * 1024);
	frame_arena = ref frame_arena_val;
};

destroy_arenas ::= func( -> v0)
{
	putzstr("arena free: ");
	putuint(global_arena_val.cur);
	putzstr("B");
	putchar(10);
	arena_destroy(ref global_arena_val);
	arena_destroy(ref frame_arena_val);
};

fully_read_file ::= func(path : u8?, a : arena mut? -> u8 mut?)
{
	if(!file_exists(path))
	{
		putzstr("file ");
		putchar('"');
		putzstr(path);
		putchar('"');
		putzstr(" could not be located (cwd: ");
		cwd : u8? mut;
		cwdlen : u64 mut;
		directory_get_cwd(ref cwd, ref cwdlen, global_arena);
		putbytes(cwd, cwdlen);
		putzstr(")");
		__debugbreak();
	}
	len ::= file_size_bytes(path);
	if(len == 0)
	{
		putzstr("warning: file ");
		putchar('"');
		putzstr(path);
		putchar('"');
		putzstr(" exists but is empty");
	}
	data : u8 mut? := arena_alloc(a, len + 1);
	file_read(path, data, len);
	deref(data # len) = 0;
	return data;
};

argc : s32 mut;
argv : u8?? mut;
envp : u8?? mut;

json_parse_buffer_named ::= func(name : u8?, buf : u8?, len : u64, a : arena mut? -> json_data)
{
	tokens ::= json_lex(name, buf, len, false, a);
	return json_do_parse(tokens, global_arena, false);
};

json_parse_buffer ::= func(buf : u8?, len : u64, a : arena mut? -> json_data)
{
	return json_parse_buffer_named("<untitled>", buf, len, a);
};

json_parse_file ::= func(path : u8?, a : arena mut? -> json_data)
{
	source ::= fully_read_file(path, a);
	return json_parse_buffer_named(path, source, zstrlen(source), a);
};

json_print ::= func(j : json_data -> v0)
{
	json_data_verbose_print(j, 0);
};

json_array_length ::= func(j : json_data -> u64)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.array))
		{
			putzstr("json_array_length called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
	}
	return j.childcount;
};

json_object_field_count ::= func(j : json_data -> u64)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.object))
		{
			putzstr("json_object_field_count called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
	}
	return j.childcount;
};

// retrieve a field of an object by index. the index must be in range (see json_object_field_count)
json_object_get_field ::= func(j : json_data, field_idx : u64 -> json_data mut?)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.object))
		{
			putzstr("json_object_get_field called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
		if(field_idx >= (j.childcount))
		{
			putzstr("json_object_get_field requested index ");
			putuint(field_idx);
			putzstr(" but object only had ");
			putuint(j.childcount);
			putzstr(" fields.");
			__debugbreak();
		}
	}
	return json_data_get_child(j, field_idx);
};

// retrieve a field of an object by name
// if the object has a field by this name, its value is returned
// else zero is returned
json_object_find_field ::= func(j : json_data, name : u8?, name_len : u64 -> json_data mut?)
{
	static if(_config == "debug")
	{
		if(j.type != (json_data_type.object))
		{
			putzstr("json_object_find_field called on ");
			putchar('"');
			putzstr(__enumname(j.type));
			putchar('"');
			__debugbreak();
		}
	}
	i : u64 mut;
	for(i = 0, i < (j.childcount), i = i + 1)
	{
		field ::= json_data_get_child(j, i);
		// field is a string
		// stringdata is the name of the field
		// its only child is the field value
		if(field->chars_len == name_len)
		{
			if(streql_n(field->chars, name, name_len))
			{
				// this is the one
				return json_data_get_child(deref field, 0);
			}
		}
	}
	return zero;
};

json_string_length ::= func(j : json_data -> u64)
{
	return j.chars_len;
};

json_string_data ::= func(j : json_data -> u8?)
{
	return j.chars;
};

main ::= func(iargc : s32, iargv : u8??, ienvp : u8?? -> s32)
{
	argc = iargc;
	argv = iargv;
	envp = ienvp;
	setup_arenas();
	defer destroy_arenas();
	json_lex_setup(global_arena);

	args ::= json_parse_args(global_arena);
	if(args.file == zero)
	{
		putzstr("error: no file provided");
		putchar(10);
		__debugbreak();
	}
	json ::= json_parse_file(args.file, global_arena);
	json_print(json);

	fieldname ::= "glossarY";
	search ::= json_object_find_field(json, fieldname, zstrlen(fieldname));
	if(search == zero)
	{
		putzstr("field ");
		putchar('"');
		putzstr(fieldname);
		putchar('"');
		putzstr(" not found.");
		putchar(10);
	}
	else
	{
		json_print(deref search);
	}
	
	return 0;
};
